---
title:  "[C++] 백준 1302 [베스트셀러]"
excerpt: ""

categories:
  - Baekjoon
tags:
  - [algorithm, cpp, map]

breadcrumb: true
toc: true
toc_sticky: true
 
date: 2024-01-02
last_modified_at: 2024-01-02
---

### 문제설명
input 1 : 책의 수(n)<br>
input 2~n+1 : 책<br>
2~n+1까지의 책 중 가장 많이 입력된 책을 출력하고, 동일한 갯수이면 사전순으로 더 앞에 오는 책을 출력한다.<br>

### 풀이방법
여러가지 풀이방법을 생각해보았다.<br>
1. python의 dictionary 사용<br>
2. c++의 vector와 pair 사용<br>

먼저, 처음 2번으로 풀었을 때의 코드는 다음과 같다.

### 소스코드 1
```cpp
#include<iostream>
#include<vector>
#include<cstring>
using namespace std;

int main(){
  int n;
  int max_count = -1;
  string max_book_title;
  vector<pair<string, int> > books;
  cin >> n;
  string s;
  for(int i=0; i<n; i++){
    cin >> s;
    bool flag = true;
    for(int j=0; j<books.size(); j++){
      if(books[j].first == s){
        flag = false;
        books[j].second = books[j].second+=1;
      }
    }
    if(flag) books.push_back(make_pair(s, 1)); 
  }
  for(auto i : books){
    if(max_count < i.second){
      max_count = i.second;
      max_book_title = i.first;
    }   
    else if(max_count == i.second){
      if(max_book_title > i.first){
        max_book_title = i.first;
      }
    }
  }
  cout << max_book_title;
}
```

맞는 코드이긴 하지만, 맘에 들지 않는다. <br>
python으로는 dictionary, c++에서는 map을 활용하면 더 간단하게 구현할 수 있더라.<br>
오랜만에 C++ STL을 사용하려니 vector와 pair밖에 기억이 안났다..<br>

그러면 map 사용법부터 다시 익혀보자.

### map 사용법

#### header
```cpp
#include <map>
```

#### empty container constructors
```cpp
map<key_type, value_type> first;
first['a']=10;
first['b']=30;
first['c']=50;
first['d']=70;
```
가장 많이 쓰는 constructor 형태이다.
map의 key는 중복을 허용하지 않는다.

#### range constructor
```cpp
map<key_type, value_type> second(first.begin(), first.end());
# a,b,c,d

map<key_type, value_type> second(first.begin(), first.find('c'));
# a,b

map<key_type, value_type> second(first.find('b'), first.lower_bound('d'));
# b,c

map<key_type, value_type> second(first.find('b'), first.upper_bound('c'));
# b,c
```
여러가지 iterator 관련 member function으로 위와 같이 특정 범위만 copy하여 range constructor를 구성할 수 있다.

#### insert vs emplace
```cpp
first.insert(make_pair<key_type, value_type>('e', 5));

first.emplace('e', 5);
```

insert : insert element <br>
emplace : **Construct** and insert elements

insert 보다는 emplace가 편하다.<br>

map에서 중요한 점은 key의 오름차순으로 정렬되어 있다는 것이다.
이는 binary search tree중 Red Black Tree로 구현되어 있다는 점 때문인데, 이러한 특성 때문에 unordered_map보다 access 속도가 느리다.<br>

만약 내림차순으로 정렬하려면, 다음과 같이 작성하면 된다.

```cpp
map<key_type, value_type, greater<key_type> > first;
```

### 소스코드 2
```cpp
#include <iostream>
#include <map>
#include <cstring>

using namespace std;

int main(){
  int n, max_book_count=0; string s;
  map<string, int> m;
  cin >> n;

  for(int i=0; i<n; i++){
    cin >> s;
    m[s]++;
  }
  
  for(auto i : m){
    max_book_count = max_book_count < i.second ? i.second : max_book_count;
  }
  for(auto i : m){
    if(i.second == max_book_count){
      cout << i.first;
      break;
    } 
  }
}
```