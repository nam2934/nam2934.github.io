---
title:  "Ruby on Rails [Chapter 2]"
excerpt: ""

categories:
  - RubyonRails
tags:
  - [ruby, rails, Github]

breadcrumb: true
#classes: wide
toc: true
toc_sticky: true
 
date: 2021-06-06
last_modified_at: 2021-06-06
---

# CH_2 A toy app
## 들어가며,,
이번 챕터에서는 레일즈의 성능을 확인할 수 있는 toy앱을 만들 것이다.
scaffold generator 를 이용해 애플리케이션을 빠르게 생성해서 레일즈 프로그래밍의 개괄적인 개요를 얻는게 목적이다.
책의 나머지 부분은 sample app을 점진적으로 개발해서 새로운 개념을 서서히 배우겠지만, 
빠른 개요를 위해서는 scaffold를 사용해야 한다.
toy app은 URL을 통해 상호작용할 수 있게 되어 레일즈가 선호하는 REST 아키텍쳐에 대해 배울수 있고, 레일즈 어플리케이션의 구조에 대한 통찰력을 얻을 수 있다.
여기서는 Sample app 과 마찬가지로, toy app은 사용자 및 관련 마이크로포스트로 구성된다. 즉, 미니멀리스트 트위터 스타일의 앱을 만든다. 
이 튜토리얼의 요점은 레일즈를 더 깊이 이해하기 위해 scaffold 중심적인 접근 방법을 넘어서야 한다는 것이다. 즉, scaffold 만으로 어플을 구성하는 것을 뛰어넘어서 그 기능을 하나하나 직접 구현할 수 있어야 한다.

##  2.1 Planning the application
자, toy app 프로젝트를 시작하자.
1장에서 배웠듯이 다음과 같은 명령어를 입력하면 된다.
```bash
$ rails _5.2.3_ new toy_app
$ cd toy_app/
```

그리고 application controller에서 1장에서 했던 것과 똑같이 hello action을 만들고, route를 바꿔준다.

경로 : app/ controllers/ application_controller.rb
```ruby
class ApplicationController < ActionController::Base
    def hello
        render html: "hello, world!"
    end
end
```

경로 : config/ routes.rb
```ruby
Rails.application.routes.draw do
  root "application#hello"
end
```

이제 우리는 진짜 앱을 만들 준비가 됐다. 웹어플리케이션을 만들 때 전형적인 첫번째 단계는   우리의 어플리케이션의 구조를 표현하는 data model을 만드는 것이다. 우리는 트위터 스타일의 마이크로 포스트를 만들 것이다. 그래서 먼저 이 app의 user model을 만들 것이다.

### 2.1.1. A toy model for users

user data model을 만들때에는 웹의 다양한 유저 등록 양식 만큼이나 많은 선택지가 있다.
단순함을 위해서, 우리는 최소한의 접근을 할 것이다.
toy app의 Users는 특별한 식별자인 id와 공통적으로 볼 수 있는 name(string type), email addres 를 가진다고 하자.

[image:F8579FC8-07A0-4971-B79B-D3CE13EBE660-41397-0000499958346A07/image.png]

### 2.1.2 A toy model for microposts

micropost data model의 핵심은 user model보다 훨씬 간단하다. 왜냐면 micropost는 오직 id와 content만 가지고 있기 때문이다. 하지만 추가적인 문제가 있다. 각 마이크로포스트를 특정 사용자와 연결하고자 한다. 게시물 소유자의 user_id를 기록하여 이 작업을 수행 할 것이다.

[image:EC2F92AF-AF5A-4EC6-A56B-8AF542D919CB-41397-0000499B0CDC4B87/image.png]

## 2.2. The Users resource

이 장에서는 2.1.1의 User data model을 해당 모델에 대한 웹 인터페이스로 구현한다. 이 조합은 user 리소스를 구성하며, HTTP 프로토콜을 통한 웹을 통해 User를 create, read, update, delete할 수 있다.
User resource는 scaffold generator 를 통해 생성 할 것이다. 만들어진 코드를 너무 자세히 보지는 말자. 이 단계에서는 혼란만 일으킬 뿐이다. 
rails scaffold는 rails generate 스크립트에 전달하여 생성된다. scaffold의 첫번째 argument는 리소스 이름이고, 두번째 이상부터는 data model의 속성이다.

`$ rails generate scaffold User name:string email:string`

위 명령어를 보면 리소스 이름은 User, User의 속성인 name과 email의 타입을 적어준다.
id 파라미터는 레일즈에서 알아서 만들어 준다.(primary key)

toy application을 진행하기 위해서는 migrate를 먼저 해야된다.

`$ rails db:migrate`

migrate를 하는 이유는 database에 users data model을 업데이트 하기 위함이다.
참고로 레일즈 5 이전 버전에서는 rails 대신 rake 를 사용하므로, 기존 어플리케이션을 위해 rake 사용법을 아는것이 중요하다.

옛날부터 Unix의 make 유틸리티는 소스 코드에서 실행 가능한 프로그램을 구축하는 데 중요한 역할을 해왔다. rake는 ruby make 이고 루비로 쓰여진 Make-like 언어이다.
레일즈 5 이전에는 ruby on rails서 rake를 광범위하게 사용했으므로, 기존 레일즈 어플리케이션을 위해서는 rake를 사용하는 방법을 아는 것이 중요하다. 레일즈 문법에서 가장 일반적인 두가지 rake 명령은
rake db:migrate, rake test 이다. 
이러한 레이크의 사용에서는 command가 rails 응용 프로그램의 gem 파일에 해당하는 rake 버전을 사용하는지 확인하는 것이 중요하다. 
이 버전은 bundle exec 명령을 사용하기 때문에
`$ rake db:migrate`
대신에
`$ bundle exec rake db:migrate`
를 사용할 것이다.

`$ rails server -b 0.0.0.0`

을 입력 한 후에 다음 url로 이동해보자.
[image:194B4EA9-5B23-428D-BC0A-B9A4C5B9D927-42269-00004C7FBE95D432/image.png]

### 2.2.1 A user tour

/의 root URL을 방문하면 “hello, world!” 페이지가 나오지만, user resource scaffold를 생성해서 user을 조작하기 위한 페이지도 많이 생성되었다. 
예를들면, 모든 사용자를 나열하는 페이지는 / users에 있고, 새 사용자를 만드는 페이지는 / users/ new에 있다.  이 섹션의 나머지 부분은 이러한 user page를 대략 둘러볼 것이다.
위의 url 표를 참고하는 것이 도움이 될 것이다.

사용자를 만든 후에는 /users /1 에 들어가면 primary key 가 1인 사용자를 볼 수 있다. 
저 1이 의미하는 것은 user id가 1인 것이고, 두번째 사용자를 만들면 /users/2에 들어가면 될 것이다. 
사용자 정보를 변경하려면 /users /1 /edit 페이지를 방문하면 된다. 

또 /users 페이지에서 destroy 를 누름으로써 사용자를 삭제할 수 있다.

#### Exercises

1. email 없이 입력하면 어떻게 되나?
A : 없어도 그냥 생성된다.

2. invalid email address 를 입력했을 때는 어떻게 되나?
A : 그냥 생성된다.

3. 데이터를 삭제하면 어떤 메시지가 뜨나?
A : User was successfully destroyed 라고 뜬다.

### 2.2.2 MVC in action

우리는 이제 빠르게 Users resource 에 대해서 둘러봤다. 
이제 MVC 패턴의 맥락에서 User resource의 특정 부분을 살펴보겠다. /users 를 MVC 측면에서 설명하는 것이다.

[image:EA32D7D1-EFA5-4665-AD7E-2E546738AFD4-42269-00004CA14DF6000A/image.png]

1. 브라우저가 /users URL에 대한 요청을 발행함.
2. User controller의 index action으로 /users 를 라우팅한다.
3. index action은 User model의 모든 사용자(User.all)를 검색하도록 요청한다.
4. User model은 데이터베이스에서 모든 사용자를 가져온다.
5. User model은 사용자 목록을 사용자 목록을 컨트롤러로 반환한다.
6. 컨트롤러가 index view로 전달되는 @users variable안의 사용자를 점유한다.
7. view는 내장된 루비를 사용해서 HTML로 페이지를 렌더링한다.
8. 컨트롤러는 다시 브라우져로 HTML을 패스한다.

이제 위의 단계를 좀 더 자세히 살펴보겠다. 먼저 브라우저에서 발급된 요청으로 시작한다.(URL을 입력하거나, 링크를 클릭()
이 요청은 Rails router를 부르고, URL을 기반으로 request를 적절한 컨트롤러 작업으로 전송한다. URL과 컨트롤러 액션 매핑을 생성하는 코드는 다음과 같다.
(resource :users)

경로 : config/ routes.rb
```ruby
Rails.application.routes.draw do 
	resources :users 
	root 'application#hello' 
end
```

root route를 보면 Application controller에 있는 hello action 인데, 현재 우리는 User  controller에 있는 index action을 루트로 하고 싶기 때문에 다음과 같이 바꿔준다.

경로 : config/ routes.rb
```ruby
Rails.application.routes.draw do 
	resources :users 
	root 'users#index' 
end
```

컨트롤러는 연관된 action의 집합체를 포함하고 있으며, 섹션 2.2.1 의 페이지 둘러보기는 User controller의 action에 해당된다.
컨트롤러는 scaffolding에 의해 생성됐으며, 이것은 다음과 같이 보여진다.

[image:3A01928F-2DF4-444C-8A87-92313E2F0D26-42269-00004CAC25A0E46C/image.png]
[image:58CD489A-9D12-4BC4-8137-E88DFF05981B-42269-00004CAC6624E290/image.png]

index, show, new, edit 액션들은 섹션 2.2.1에 나와있다. 그러나 create, update, destroy 같은 추가적인 액션들도 있다. 이 액션들은 일반적으로 페이지를 렌더링하지 않으며 대신에 데이터베이스의 사용자에 대한 정보를 수정하는 것이 주요 목적이다.
이 전체 컨트롤러 action들은 다음과 같다.

[image:5795BF74-C8AB-43A6-87FC-780861441302-42269-00004CB341F78841/image.png]

위는 REST 아키텍쳐 구현을 나타낸다. URL에 일부 중복이 있다.
예를 들어, show action과 update action 모두 URL /users /1 에 해당된다.
이들 간의 차이점은 응답하는 HTTP 요청 방법이다. GET, POST, PATCH, DELETE등이 있다.

REST 는 REprentational State Transfer의 약자이다. 또, web 및 web application과 같은 분산 네트워크 시스템 및 소프트웨어 어플리케이션을 개발하기 위한 아키텍처 스타일이다. REST이론은 다소 추상적이지만, 레일즈 어플리케이션의 맥락에서 REST는 대부분 어플리케이션의 구성요소가 관계형 데이터베이스 CRUD 작업과 충족된 4가지 기본 HTTP 요청에 모두 해당하는 작업을 생성, 읽기, 업데이트 및 삭제할 수 있는 리소소를 모델링 된다는 것을 의미한다. POST, GET, PATCH, DELETE 등이다.

RESTful 개발 방식은 created, read, update, deleted 리소스를 사용해서 구현하기만 하면 된다. User 및 micropost의 경우 이러한 과정은 간단하다. 왜냐햐면 그들은 본래 그들 고유의 자원이기 때문이다. 

경로 : app/ controllers/ users_controller.rb
```ruby
class UsersController < ApplicationController 
. 
. 
. 
	def index 
		@users = User.all 
	end 
. 
. 
. 
end
```

@users = User.all 의 의미는 User 모델의 모든 사용자를 검색해서 @users에 담으라는 얘기이다.

이 @users는 index.html.erb 파일에서 나타난다.

### 2.2.3 Weakness of this Users resource

이 유저 모델의 단점이 있다.
* 데이터 validation이 없다.
* 사용자 인증이 없다.
* 테스트가 없다.
* 스타일과 레이아웃이 없다.
* 스캐폴딩 코드라서 실제로 어떻게 작동하는지 보이지 않는다.

## 2.3 The Microposts resource

### 2.3.1 A micropost microtour

`$ rails generate scaffold Micropost content:text user_id:integer`
`$ rails db:migrate`

이거를 입력하고 라우트를 보자.

경로 : config/ routes.rb
```ruby
Rails.application.routes.draw do 
	resources :microposts 
	resources :users 
root 'users#index' end
```

microposts 리소스가 포함되었다.

[image:7811D504-3D57-4C75-832D-CCFDCFE55562-42269-00004CE3F299A247/image.png]

라우팅은 위와 같이 되어있다.

이제 user 모델과 같이 구성 되어있고, 게시글을 작성 할 수 있다.

### 2.3.2 Putting the micro in microposts

micro라는 이름에 걸맞게 긴 내용이 포함되면 안되게 해보겠다.

경로 : app /models /micropost.rb
```ruby
class Micropost < ApplicationRecord
    validates :content, length: { maximum: 140 }
end
```

최대 길이를 140자를 못 넘게 만들었더니 다음과 같이 메시지가 뜬다.

[image:9361E1D0-FE6E-4F30-812F-E5D4479ADD65-42269-00004CE6BC336207/사진 2021. 1. 2. 오후 85327.jpg]

### 2.3.3 A user has_many microposts

rails의 강력한 기능 중 하나는 서로 다른 data model의 associations이다.
우리의 경우 User model은 has many microposts가 가능하다.
이것을 다음과 같이 나타낼 수 있다.

경로: app /models /users.rb
```ruby
class User < ApplicationRecord
    has_many :microposts
end
```

경로: app /models /micropost.rb
```ruby
class Micropost < ApplicationRecord
    belongs_to :user
    validates :content, length: { maximum: 140 }
end
```

[image:34D9057A-5FBE-4E13-9184-74A0251B6959-42269-00004CE85B001177/image.png]
위와 같은 association이 있다.

rails console 에서 다음을 확인 할 수 있다.

```bash
$ rails console 
>> first_user = User.first 
=> #<User id: 1, name: "Michael Hartl", email: "michael@example.org", created_at: "2016-05-15 02:01:31", updated_at: "2016-05-15 02:01:31"> 
>> first_user.microposts 
=> [#<Micropost id: 1, content: "First micropost!", user_id: 1, created_at: "2016-05-15 02:37:37", updated_at: "2016-05-15 02:37:37">, #<Micropost id: 2, content: "Second micropost", user_id: 1, created_at: "2016-05-15 02:38:54", updated_at: "2016-05-15 02:38:54">] 
>> micropost = first_user.microposts.first # Micropost.first would also work. => #<Micropost id: 1, content: "First micropost!", user_id: 1, created_at: "2016-05-15 02:37:37", updated_at: "2016-05-15 02:37:37"> 
>> micropost.user => #<User id: 1, name: "Michael Hartl", email: "michael@example.org", created_at: "2016-05-15 02:01:31", updated_at: "2016-05-15 02:01:31"> >> exit
```

이전에 micropost에 길이 validates를 줬는데, blank는 안된다는 validation은 다음과 같다.

경로 : app /models /microposts.rb
```ruby
class Micropost < ApplicationRecord
    belongs_to :user
    validates :content, length: { maximum: 140 }, presence: true
end
```

presence: true 를 추가하면 된다.

user.rb에 validation을 추가하면 다음과 같다.

경로 : app /model /user.rb
```ruby
class User < ApplicationRecord
    validates :name, presence: true
    validates :email, presence: true
    has_many :microposts
end
```

### 2.3.4 Inheritance hierachies

이제 레일즈의 컨트롤러 및 모델 클래스 계층 구조에 대한 간략한 설명으로 toy app에 대한 논의를 마칠 것이다.
이 논의는 OOP에 대한 경험이 있는 경우에만 의미가 있다. 당장은 혼란스럽더라도 걱정하지 않아도 된다.

먼저 모델에 대한 상속 구조부터 살펴보겠다. 
User 모델과 Micropost 모델이 ApplicationRecord에서 상속되고(‘<‘를 통해), 다음으로 ActiveRecord::Base에 상속된다.
이 관계를 요약한 다이어그램이 다음과 같다.
[image:07BC7B59-CCB7-4C7C-B58F-30C64AEE6A6B-43090-00004D0A95F6EC6B/image.png]
ActiveRecord::base를 상속받음으로써 우리의 모델 객체들은 데이터베이스와 통신하고 데이터베이스 column들을 루비 속성으로 처리하는 등의 기능을 얻을 수 있다.
[image:6378A1FE-F886-4B08-A8A5-DD56E41D04F4-43090-00004D0C4A33F255/image.png]

컨트롤러의 상속 구조는 기본적으로 모델의 상속 구조와 동일하다. 아래를 보면 Users controller와 Microposts controller가 모두 Application controller로부터 상속된다는 것을 알 수 있다.
[image:0B79F5B9-7475-45C4-8689-1817FA3B5CD9-43090-00004D0B97D45236/image.png]

아래 그림을 보면 Application Controller 자체가 ActionController로부터 상속된다는 것을 알 수 있다. 
[image:0151F77D-01E0-40A9-BE6D-7323E00F84DA-43121-00004D0EC82F1EB0/image.png]

ActionController는 Rails 라이브러리 Action Pack에서 제공하는 컨트롤러의 기본 클래스이다. 이러한 class와의 관계는 아래 그림과 같다.
[image:77D0C300-C194-4B59-83DC-F945090B5D53-43121-00004D0EA1C13253/image.png]

모델 상속과 마찬가지로, Users와 Microposts 컨트롤러는 모두 기본 클래스(ActionController::base) 로부터 상속받음으로써 많은 기능을 얻을 수 있다. 여기에는 모델 객체를 조작하고 인바운드 HTTP 요청을 필터링하며 view를 HTML로 렌더링 하는 기능이 포함된다.
모든 레일즈 컨트롤러가 Application Controller부터 상속받으므로, Application controller에 정의된 규칙은 모든 action에 자동으로 적용된다. 

## 2.4 Conclusion
잘 알고있는 것 :
* 레일즈 훝어보기
* MVC에 대한 소개
* REST architecture
* data modeling 시작하기
* 동적인 db-backed 웹 어플리케이션 개발

잘 모르는 것 :
* 레이아웃 커스텀
* 정적페이지 존재 x
* 유저 비밀번호 x
* 유저 사진 x
* 로그인 x
* 보안 x
* 자동적인 user/micropost 연관성
* “following” 또는 “followed”의 뜻
* micropost feed x
* tdd x
* 실제로 이해 x

### 2.4.1 What we learned in this chapter
* 스캐폴딩은 모델 데이터와 웹을 통한 상호작용에 대한 코드를 자동으로 생성한다.
* 스캐폴딩은 빠르게 시작하기 좋지만, 이해하는데는 안좋다.
* rails는 MVC 패턴을 사용한다.
* Rails에서 해석한 바와 같이, REST 아키텍처는 데이터 모델과 상호 작용하기 위한 표준 URL 및 컨트롤러 작업을 포함한다.
* Rails는 데이터 모델 속성에 대한 제약을 걸기위해 data validation을 지원한다.
* 레일즈는 서로 다른 데이터 모델의 연관성을 정의하기 위한 함수가 내장되어 있다.
* rails console을 통해 커맨드라인으로 rails application과 상호작용이 가능하다. 